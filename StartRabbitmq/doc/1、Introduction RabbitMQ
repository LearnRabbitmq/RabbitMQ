三种Queue:
1、Apache ActiveMQ  可能会丢失消息
2、ZeroMQ  不支持消息持久化和崩溃恢复
3、RabbitMQ  我们的选择

RabbitMQ基础知识:
首先是Erlang语言写的，支持持久化，如果RabbitMQ死掉了，消息不会丢失，当队列重启
一切都会回来，可以和python实现无缝结合

4个重要的概念：
虚拟主机(virtual host), 交换机(exchange), 队列(queue), 绑定(binding)
一个虚拟主机有一组交换机，队列，绑定。
为什么需要多个虚拟主机呢？
很简单，RabbitMQ当中，用户只能在虚拟主机的粒度进行权限控制。
因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。
每一个RabbitMQ服务器都有一个默认的虚拟主机“/”。

1) 队列(Queues): 是消息(messages)的终点，可以理解成装消息的容器，消息就一直在这里，
直到有客户端(消费者 Consumer) 连接这个队列并且将其取走。
需要记住的是，队列是由消费者通过程序建立的，如果一个消费者试图建立一个已经存在的队列，RabbitMQ
会忽略这个请求。
现在假如你的消费者现在已经建立了一个队列，正在等待消息的到来，但是你需要把消息放到一个队列才可以。
不过如果想要做这一步，(怎样才能把消息放到一个队列当中呢？)你需要一个交换机(exchange)

2) 交换机(exchange): 交换机可以理解成具有路由表的路由程序。每一个消息(消息必须放到队列中)
都有一个属性成为路由键(routeing key)就是一个简单的字符串(消息的属性：路由键)，交换机当中有一系列的绑定(banding)
即路由规则(routes)。例如：指明具有路由键的'X'的消息要到名为X的队列当中去。
消息的属性：路由键(routeing key)
交换机：一批bangding，即routes，把消息送到哪个队列中

你的消费者程序负责创建你的交换机们(复数)：每个交换机在自己独立的进程当中执行，
因此增加多个交换机就是增加多个进程，可以充分利用服务器上的CPU核以便达到更高的效率。
例如，在一个8核的服务器上，可以创建5个交换机来用5个核，另外3个核留下来做消息处理。
类似的，在RabbitMQ的集群当中，你可以用类似的思路来扩展交换机一边获取更高的吞吐量。

好的，现在你已经创建了一个交换机了。但是他并不知道要把这个消息送到那个队列，你需要路由规则，即绑定(banding)
一个绑定就是类似于这样的规则，举例：
将交换机'A'当中的具有路由键'B'的消息送到队列C里面。简单的讲就是将哪个交换机中含有什么路由键的消息送到那个队列里面。
一个绑定就是一个基于路由键将交换机和队列连接起来的路由规则。
具有路由键“A”的消息需要被送到两个队列，“B”和“C”。
要做到这个，就需要创建两个绑定，每个都连接一个交换机和一个队列，
两者都是由“A”路由键触发。在这种情况下，交换机会复制一份消息并且把它们分别发送到两个队列当中。
交换机不过就是一个由绑定构成的路由表。

3) 交换机类型多种
为什么会有多种？
交换机有多种类型。他们都是做路由的，不过接受不同类型的绑定。为什么不创建一种交换机来处理所有类型的路由规则呢？
因为每种规则用来做匹配分子的CPU开销是不同的。
例如，一个“topic”类型的交换机试图将消息的路由键与类似“dogs.*”的模式进行匹配。
匹配这种末端的通配符比直接将路由键与“dogs”比较（“direct”类型的交换机）要消耗更多的CPU。
如果你不需要“topic”类型的交换机带来的灵活性，
你可以通过使用“direct”类型的交换机获取更高的处理效率。那么有哪些类型，他们又是怎么处理的呢？

Fanout Exchange – 不处理路由键，广播到绑定交换机上的所有队列。你只需要简单的将队列绑定到交换机上。
一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。
很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。

Direct Exchange – 处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。
这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，
不会转发dog.puppy，也不会转发dog.guard，只会转发dog。

Topic Exchange – 将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。
符号“#”匹配一个或多个词，
符号“*”匹配不多不少一个词。
因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”。


4) 持久化
队列和交换机有一个创建时候指定的标志durable，直译叫做坚固的。
durable的唯一含义就是具有这个标志的队列和交换机会在重启之后重新建立，
它不表示说在队列当中的消息会在重启后恢复。那么如何才能做到不只是队列和交换机，还有消息都是持久的呢？

但是首先一个问题是，你真的需要消息是持久的吗？
对于一个需要在重启之后回复的消息来说，它需要被写入到磁盘上，而即使是最简单的磁盘操作也是要消耗时间的。
如果和消息的内容相比，你更看重的是消息处理的速度，那么不要使用持久化的消息。不过对于我们来说，持久化很重要。

当你将消息发布到交换机的时候，可以指定一个标志“Delivery Mode”（投递模式）。
根据你使用的AMQP的库不同，指定这个标志的方法可能不太一样（我们后面会讨论如何用Python搞定）。
简单的说，就是将Delivery Mode设置成2，也就是持久的（persistent）即可。
一般的AMQP库都是将Delivery Mode设置成1，也就是非持久的。所以要持久化消息的步骤如下：
a) 将交换机设成 durable。
b) 将队列设成 durable。
c) 将消息的 Delivery Mode 设置成2 。

绑定（Bindings）怎么办？我们无法在创建绑定的时候设置成durable。
没问题，如果你绑定了一个durable的队列和一个durable的交换机，RabbitMQ会自动保留这个绑定。
类似的，如果删除了某个队列或交换机（无论是不是durable），依赖它的绑定都会自动删除。

注意两点：
a) RabbitMQ 不允许你绑定一个非坚固（non-durable）的交换机和一个durable的队列。反之亦然。
要想成功必须队列和交换机都是durable的。
b) 一旦创建了队列和交换机，就不能修改其标志了。
例如，如果创建了一个non-durable的队列，然后想把它改变成durable的，唯一的办法就是删除这个队列然后重现创建。
因此，最好仔细检查创建的标志





